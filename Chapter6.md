При разработке структуры данных, с которой будет взаимодействовать значительное количество потоков, существует два основных подхода:

1. **Неизменяемая (Immutable) структура данных:**
   - Структура данных не поддается изменению после своего создания.
   - Инварианты структуры сохраняются на протяжении всего ее существования.
   - Поскольку данные неизменяемы, отпадает необходимость в синхронизации при доступе из разных потоков.
   - Поддерживается потокобезопасность за счет отсутствия изменений внутри структуры.

2. **Структура данных, специально спроектированная для многопоточного доступа:**
   - Используются механизмы синхронизации, такие как мьютексы, атомарные операции и другие средства, чтобы обеспечить корректный доступ из разных потоков.
   - Инварианты структуры поддерживаются с использованием соответствующих методов синхронизации.
   - Позволяет более гибкое управление данными в процессе их жизненного цикла, так как они могут быть изменены.

Для обеспечения потокобезопасности структуры данных при различной гранулярности доступа потоков следует выполнить следующие шаги:

**Гарантировать безопасность доступа:**
- Структура данных должна предоставлять интерфейс, который не допускает доступ к данным в состоянии с нарушенными инвариантами.
- Операции с данными должны быть атомарными, не предоставляя возможности для частичного выполнения операций.
- Предотвращение искажения данных или нарушения инварианта даже в случае исключений.
- Минимизация возможности взаимных блокировок при синхронизации.

**Спроектировать с истинной параллельностью доступа:**
- Разработка структуры данных с учетом истинной параллельности, позволяя потокам работать над различными частями структуры асинхронно.
- Определение гранулярности доступа для каждой операции, с целью минимизации синхронизации.
- Ограничение областей действия, чтобы часть операций выполнялась без блокировки.
- Использование нескольких мьютексов для различных частей структуры, чтобы избежать влияния доступа к одной части на другие.
- Вопросы о том, нужен ли одинаковый уровень защиты для всех операций, и как можно изменить структуру данных для достижения большей параллелизации. Без изменения требований к задаче (интерфейсу)


**Монопольный доступ:**
Гарантировать монопольный доступ к 
- конструктору
- деструктору
- операциям присваивания
- конструктору копирования
- мув-конструктору 
- мув-присваиванию
так чтобы обеспечить корректное создание, уничтожение копирование и перемещение структуры данных.

Алгоритм действий при проверке структуры на безопасность доступа:
* составить список требований к структуре
* проверить базовую потокобезопасность:
	* сформулировать все инварианты для структуры
	* извне невозможно получить ссылку на данные внутри структуры
	* одновременный доступ нескольких потоков к любой комбинации вызовов методов не нарушает инвариант (проще проверять не от методов а от инвариантов)
проверка исключений
	* перебераются все места где могут вылетить исключения (выделения памяти, копирование, пользовательские методы итд) и каждый из них тестируется на кретичность и целосность инварианта в случае исключений.
	* утечки памяти или ресурсов при исключении так же проверять то чтоб все мютексы так же были гарантировано освобождены. (используй RAII)
проверка взаимоблокировок
	* проверка на то может ли пользовательский код в перегруженых методах пользовательского класса вызвать взаимоблокировку
	* операторы вроде new delete так же могут быть касотмными и вызвать взаимоблокировку
дополнительно 
	* обеспечит способ ожидание изменения состояния структуры, чтоб не тратились ресурсы на постоянное пингование
	* есть средства повторного оповещения о изменении структуры данных при неудачном вытягивании элемента из структуры ЕСЛИ ТАКАЯ ВОЗМОЖНОСТЬ ЕСТЬ (ее быть не должно)
		
стек: - так как вход и выход один, крайне плохо паралелится
очередь:
реализуется кастомный односвязный список, с блокировкой только критически важных секций head и tail
* использован трюк с фиктивным узлом, который не содержит данных. На него укахзывает tail. Это позволяет сделать так чтоб когда у нас один узел всего, нам не приходилось блокировать и head и tail в результате чего мы не сможем заблокировать один узел дважды
при добавлении элемента мы запишем данные в фиктивный, и после него установим новый узел пустым
при удалении нужно будет проверить не указывает ли Head и tail на один узел, если да значит список пустым
* перед добавлением оборачиваем данные в shared_ptr чтоб не требовалось операции создания которая может кинуть эксепшен, и сразу сможем вернуть данные по смарт поинтеру
* ноду храним в unique_ptr это позволит не волноватся о удалении узла после извлечения
* блокируется head при try_pop и tail только на момент получения tail необходим для определения пустоты очереди, так как в конец можно только добовлять, то нам нет нужды дальше держать мютекс tail
	* важно чтоб перед получением tail мы заблокировали Head (Иначе обрабатываемый узел может уйти при помощи другого pop запущеного паралельно)
* при push необходима блокировка только на момент установки нового узла, но так как мы используем фиктивный узел то на две операции:
	* установка значения последнего узла
	* установка ссылки в последний узел на новый последний фиктивный узел

опасатся реализации итераторов в многопоточке, так как с ними будет много проблем (мы можем итератором идти по дереву, где вся ветка по которой мы ходим уже удалена, или встреча итераторов двусвязного списка движущихся на встречу друг другу)

Асоциативные контейнеры
варианты реализации:
* дерево - каждое чтение/модификация требует чтения корневого узла, там будет место через которое все проходят и блокируют его, фактически не чем не будет отличатся от блокировки всей структуры
* сортированый массив - одна блокировка на весь масив
* хеш таблица - оптимально для мелко гранулярных блокировок

хеш таблица
реализуется при помощи вектора кластеров, кластер содержит все элементы содержащие ключи с одинаковыми хешами, кластер представляет собой список пар ключ занчение. Для поиска считаем хеш ключа, по индексу находим кластер, обходим список пар.
* каждый кластер блокируется отдельно - мы не можем одной опирацией читать или менять сразу несколько кластеров, соответственно нам нужно синхронизировать обращения только к одному кластеру
* блокировка кластеров происходит при помощи boost::shared_lock - позволит читать многим потокам, менять монопольно, увеличит скорость при многопоточном чтении.
* общее управление хеш таблицей проходит без блокировок
* при экспорте таблицы мы должны будем заблокировать все мютексы, чтоб хеш таблица не менялась в процессе экспорта

список
кастомный список, блокировка идет на уровне нод
* операции добавления элемента - блокируется next элемента после которого будет помещен новый элемент, после помещяется в новый элемент ссылка на следуещий (другой поток не чего не сможет сделать так как next захвачен, и между ними не кто новый не встрянет), наш элемент помещяется в next захваченого (не каких проблем так же не будет, так как мы держали его все время).
* операции обхода - блокирует текущий элемент и работает с next элементом начиная с head (хед нулевой элемент)
* операция удаления - под защитой предыдущего next извлекаем текущий элемент из next придыдущего, устанавлеваем next текущего как next следуещиго
