## Пул потоков
Thread pool (пул потоков) - это механизм в программировании, предоставляющий готовый набор потоков для выполнения задач. Идея заключается в том, чтобы избежать постоянного создания и уничтожения потоков, что может быть затратным в смысле ресурсов. Вместо этого заранее создается набор потоков, которые поддерживаются в пуле. Когда появляется задача, она передается свободному потоку из пула, и по выполнении поток возвращается обратно в пул для возможного использования другими задачами.

Простейший thread pool работает следующим образом:
- Использует общую для всех потоков потокобезопасную очередь задач. Эта очередь может быть частью самого пула или ей может владеть сам пул, а дополнительные задачи могут создаваться путем добавления задач в контейнер.
- Основан на std::Thread. Может использовать алгоритм для расчета оптимального количества потоков, или это число может быть передано заранее.
- Потоки хранятся в контейнере, возможно, через механизм guard, который занимается их join.
- В случае, если очередь задач пуста и пул не должен останавливаться, можно передавать свой квант времени дальше для эффективной обработки других задач.

Thread pool с ожиданием результата выполнения переданной задачи:
Thread pool с ожиданием результата выполнения переданной задачи будет хранить в контейнере задачи std::packaged_task, обернутые в обертку. При добавлении новой задачи она будет оборачиваться в packaged_task, а ее future будет возвращаться вызывающему коду.

Хадачи ожидающие результатов других потоков
Задачи, ожидающие результатов других потоков, могут возникнуть, например, при слиянии сортировки, когда создание и выполнение новых дочерних задач не является возможным, и результаты текущих потоков зависят от задач, которые еще не завершились. 
Для решения этой проблемы, если невозможно дождаться выполнения подзадач потоками, можно взять другую задачу из очереди и выполнить ее, вернувшись после этого к основной задаче.

Предотврощение конкуренции за очередь работает:
Предотвращение конкуренции за очередь может быть достигнуто, предоставив каждому потоку свою собственную очередь задач. Для уменьшения потенциальных перебросок кеша, можно при обращении к основной очереди задач распределять часть задач в локальные очереди каждого потока.
Тем не менее, неравномерная загрузка потоков может возникнуть. В случае неравномерной работы потоков, реализация логики переброски задач из чужих локальных очередей в свою может быть использована для балансировки нагрузки. Это позволяет разгрузить потоки, которые активно выполняют задачи, и перераспределить часть работы на потоки, которые временно не заняты.

## Прерывание потоков
Базовое прерывание потока
Базовый механизм прерывания потока предполагает наличие в прерываемой функции точек прерывания, где возможно кидание специального исключения при активации прерывания. Оповещение о прерывании осуществляется путем установки флага в потоке через `std::promise`, который передается в функцию выполнения.

Прерывания ожидания условной переменной (condition variable) потока
Прерывание по таймеру: Прерывание ожидания условной переменной (condition variable) потока осуществляется через внедрение прерывания по таймеру вместо полного ожидания. В данной реализации используется ложное пробуждение по таймеру, при этом проверяется точка прерывания.
Для прерывания с использованием `condition_variable_any` необходимо ввести мьютекс, который гарантирует, что прерывание не будет вызвано до того, как поток начнет ожидание. Иначе существует риск, что прерывание вызовет пробуждение потока до начала ожидания, и прерывание не произойдет. При этом прерывание ожидания осуществляется путем ложного пробуждения всех потоков, заблокированных данной условной переменной. Те потоки, которые не должны быть прерваны, восстанавливают свое ожидание после провала проверки предиката.

Прерывние других типов ожидания:
Только прерывание по таймеру, с более короткой проверкой придеката.