в с++ 11 была добавлена модель памяти учитывающяя многопоточность, на новой моделе памяти опираются все концепции связанные с многопоточностю описаные в предыдущих главах
атомарные переменные добавленые в том же стандарте позволяют работать с новой моделю памяти на более низком уровне, практически на уровне железа.

Структурно новая модель памяти разбивает всю общую память на ячейки, принадлежащие отдельным байтам. В этом контексте ячейкой выступает участок памяти, занимаемый определенным типом данных, независимо от количества бит, которые этот тип занимает. Например, тип char занимает 8 бит и представляет собой одну ячейку памяти, а int64, занимающий 64 бита, также является одной ячейкой. Также справедливо для пользовательских типов: если их размер соответствует ограничениям системы, они считаются одной ячейкой.

Проблемы с гонками данных в многопоточных приложениях в основном возникают при одновременном доступе к общей ячейке памяти. Когда разные потоки обращаются к разным ячейкам, обычно не возникает проблем. Однако, если несколько потоков обращаются к одной и той же ячейке, могут возникнуть ситуации, требующие синхронизации:
- **Чтение-Чтение:**
  - *Безопасно:* Множество потоков может читать данные из разных ячеек одновременно без конфликтов.
- **Чтение-Запись:**
  - *Проблема:* Возможна гонка, когда один поток читает, а другой пытается записать.
- **Запись-Чтение:**
  - *Проблема:* Также может возникнуть гонка, если один поток записывает, а другой читает.
- **Запись-Запись:**
  - *Проблема:* Гонка возможна, если два потока пытаются изменить данные одновременно.
Таким образом, для избежания гонок данных важно правильно упорядочить операции чтения и записи позволят предотвратить потенциальные конфликты.

Атомарные операции обеспечивают неделимость выполнения операций: результат либо получен, либо нет для других потоков. Они управляют чтением и записью объектов, не накладывая гарантий на сам объект. Применение атомарных операций для базовых операций, таких как +, -, ==, гарантирует их атомарное выполнение. Мы так же можем извлеч копию хранимого обекта, но операции над ним уже будут не атомарны.
Использование пользовательских типов данных (UDT) в атомарной переменной подразумевает выполнение нескольких условий:
- Должен быть определён дефолтный оператор присваивания для каждого базового класса и в каждом члене класса.
- Отсутствие виртуальных методов, особенно в базовых классах.
- Должна быть возможность проведения побитового сравнения (memcmp).
- Тип данных должен иметь фиксированный размер и быть выровнен в памяти, в противном случае использование в атомарной переменной может вызвать проблемы.
- Не рекомендуется использовать типы с плавающей точкой, так как их сравнение может привести к неожиданным результатам.

Доступные для атомарных типов функции включают:
- **is_lock_free:** Проверяет, доступны ли для объекта операции, свободные от блокировок.
- **load (ФУНКЦИЯ ЧТЕНИЯ):** Извлекает данные из атомарного типа.
- **store (ФУНКЦИЯ ЗАПИСИ):** Загружает данные в атомарный тип.
- **exchange (ФУНКЦИЯ ЧТЕНИЯ ЗАПИСИ):** Возвращает текущее значение атомарной переменной и записывает новое.
- **compare_exchange_weak (ФУНКЦИЯ ЧТЕНИЯ ЗАПИСИ):** Сравнивает ожидаемое значение с фактическим, хранящимся в атомарной переменной. При совпадении записывает желаемое значение, в противном случае обновляет текущее ожидаемое значение в атомарной переменной. Эта операция не подвержена ложным отказам.
- **compare_exchange_strong (ФУНКЦИЯ ЧТЕНИЯ ЗАПИСИ):** Сравнивает ожидаемое значение с фактическим, хранящимся в атомарной переменной. При совпадении записывает желаемое значение, в противном случае обновляет текущее ожидаемое значение в атомарной переменной. Эта операция подвержена ложным отказам, и возвращает `false`, если выполнение атомарно невозможно в данный момент.
- **fetch_add (ФУНКЦИЯ ЧТЕНИЯ ЗАПИСИ):** Добавляет значение к текущей атомарной переменной.
- **fetch_sub (ФУНКЦИЯ ЧТЕНИЯ ЗАПИСИ):** Вычитает значение из текущей атомарной переменной.
- **fetch_and (ФУНКЦИЯ ЧТЕНИЯ ЗАПИСИ):** Применяет операцию "И" к текущему значению атомарной переменной. (=&)
- **fetch_or (ФУНКЦИЯ ЧТЕНИЯ ЗАПИСИ):** Применяет операцию "ИЛИ" к текущему значению атомарной переменной. (=|)
- **fetch_xor (ФУНКЦИЯ ЧТЕНИЯ ЗАПИСИ):** Применяет операцию "исключающее ИЛИ" к текущему значению атомарной переменной. (=^)
 

Атомарные переменные обладают особенностью, известной как "принудительное упорядочивание", которое служит для организации операций и обеспечивает возможность оптимизации. Существует шесть уровней принудительного упорядочивания:
- `memory_order_seq_cst` - это наиболее строгий уровень принудительного упорядочивания в контексте атомарных операций в многопоточном программировании, установлен по дефолту. Этот уровень гарантирует следующее:
	- **Полный порядок:** Все операции чтения и записи, выполненные с использованием `memory_order_seq_cst`, устанавливают полный порядок для этих операций относительно всех остальных операций в различных потоках.
	- **Глобальная точка синхронизации:** Когда операция записи с флагом `memory_order_seq_cst` выполняется, это создает глобальную точку синхронизации, после которой все предыдущие операции, включая релаксированные, должны быть видны другим потокам.
	- **Согласованность данных:** Гарантирует, что все операции чтения и записи будут согласованы между потоками, обеспечивая предсказуемый и последовательный порядок выполнения операций.
	Этот уровень обеспечивает максимальные гарантии согласованности данных, но может потребовать больших затрат с точки зрения производительности, так как включает в себя полный порядок операций.
- **`memory_order_relaxed:`** - самый мягкий уровень принудительного упорядочивания в многопоточном программировании. Он обеспечивает минимальные гарантии синхронизации и позволяет компилятору и процессору выполнять оптимизации, не обязываясь соблюдать строгий порядок выполнения операций.
	- **Отсутствие гарантий порядка:** Не гарантирует, что операции чтения и записи будут видны другим потокам в каком-то определенном порядке.
	- **Эффективность:** Позволяет достичь лучшей производительности за счет отсутствия жестких ограничений на порядок выполнения операций.
	- **Не подходит для синхронизации зависимых данных:** Не рекомендуется использовать в ситуациях, где важен строгий порядок выполнения операций и синхронизация данных между потоками.
	- **Применение в простых сценариях:** Подходит для простых случаев, когда точный порядок выполнения операций не критичен, и производительность имеет большее значение.
	Этот уровень упорядочивания предоставляет большую свободу оптимизации, но также требует от программиста более внимательного управления синхронизацией данных в случае необходимости.
	Примерчик: Поток может получить любое значение из истории переменной, но не более раннее, чем последнее записанное или прочитанное из этого потока. Например, если последовательность значений 1, 2, 3, то при использовании этого уровня можно получить как 2, так и 3, но не 1, так как значение 1 для данного потока уже в прошлом.
- **`memory_order_acquire:`** - позволяет читать значение, записанное с использованием флага `memory_order_release`, или более новое значение, записанное с `memory_order_relaxed`. При этом такое чтение подтянет последние изменения других переменных, сделанных с релаксированным флагом, до `memory_order_release`.
	- **Установка порядка чтения:** Гарантирует, что операции чтения, выполненные текущим потоком, будут видны всем последующим операциям чтения и записи в том же потоке.
	- **Не гарантирует порядок записи:** Не обеспечивает гарантии относительно порядка выполнения операций записи в других потоках.
	- **Синхронизация чтения данных:** Используется для обеспечения согласованности данных при чтении из разделяемой памяти.
	- **Применение в критических секциях:** Обычно используется в критических секциях, где важен порядок выполнения операций чтения относительно последующих операций чтения и записи.
	Этот уровень является более строгим, чем `memory_order_relaxed`, и предоставляет более предсказуемый порядок выполнения операций чтения внутри текущего потока.
- **`memory_order_release:`** - позволяет записать данные так, чтобы `memory_order_acquire` смог подтянуть их как последнее обновление (если были релаксированные записи, то они могут подтянуться как более поздние). Также при чтении с флагом `memory_order_acquire`, это позволит подтянуть релаксированные изменения других переменных, сделанные до этого.
	- **Установка порядка записи:** Гарантирует, что все предшествующие операции чтения и записи, выполненные текущим потоком, будут видны всем последующим операциям чтения и записи в других потоках.
	- **Не гарантирует порядок чтения:** Не обеспечивает гарантий относительно порядка выполнения операций чтения в других потоках.
	- **Синхронизация записи данных:** Используется для обеспечения согласованности данных при записи в разделяемую память.
	- **Применение в критических секциях:** Часто используется в критических секциях, где важен порядок выполнения операций записи относительно последующих операций чтения и записи в других потоках.
	Этот уровень является более строгим, чем `memory_order_relaxed` и `memory_order_acquire`, и обеспечивает более предсказуемый порядок выполнения операций записи относительно других потоков.
- **`memory_order_acq_rel:`** - уровень принудительного упорядочивания в многопоточном программировании, предоставляющий как гарантии `memory_order_acquire`, так и `memory_order_release`. Этот уровень позволяет устанавливать порядок выполнения операций чтения и записи внутри текущего потока и взаимодействовать с другими потоками.
	- **Установка порядка чтения и записи:** Гарантирует, что все предшествующие операции чтения и записи в текущем потоке будут видны всем последующим операциям чтения и записи внутри этого потока. Также обеспечивает видимость всех предшествующих операций чтения и записи для других потоков после выполнения операции с флагом `memory_order_acq_rel`.
	- **Синхронизация чтения и записи данных:** Используется для обеспечения согласованности данных при чтении и записи в разделяемую память.
	- **Применение в критических секциях:** Широко используется в критических секциях, где важны порядок выполнения операций чтения и записи относительно текущего потока и других потоков.
	Этот уровень обеспечивает более высокий уровень гарантий, чем `memory_order_acquire` или `memory_order_release` по отдельности, и является полезным для сценариев, где требуется комплексная синхронизация между потоками.
- **`memory_order_consume:`** Это уровень принудительного упорядочивания, который является аналогом `memory_order_release`, но менее строгим. Он предназначен для использования в качестве оптимизации, особенно в контексте чтения данных с общей памяти.
  - **Не подтягивает все изменения:** В отличие от `memory_order_release`, `memory_order_consume` не гарантирует подтягивание всех изменений, а только те, которые необходимы для выполнения конкретной операции. Это означает, что он обеспечивает только прямую зависимость от необходимых данных.
  - **Используется для оптимизации:** `memory_order_consume` может использоваться там, где требуется более легковесная модель доступа к данным, и подтягивание всех изменений не является необходимым. Он обеспечивает более слабые гарантии, чем более строгие уровни, но при этом может предоставить более эффективные оптимизации.
  - **Применяется для инициализации и передачи данных:** `memory_order_consume` может быть полезным, например, при инициализации переменной и ее передаче другому потоку. Он позволяет извлечь значение переменной, но не гарантирует подтягивание всех изменений, что делает его менее затратным в определенных сценариях.


Барьер памяти - это специальная инструкция в многопоточных программах, которая обеспечивает определенный порядок выполнения операций чтения и записи в разделяемой памяти.
Барьеры памяти часто используются для обеспечения согласованности данных между потоками. Они могут быть разделены на два основных типа:
1. **Барьеры для чтения (`acquire barriers`):** Гарантируют, что все предшествующие операции чтения (включая релаксированные) внутри текущего потока завершатся перед выполнением барьера. Таким образом, барьер для чтения обеспечивает видимость всех изменений переменных до барьера для последующих операций чтения.
2. **Барьеры для записи (`release barriers`):** Гарантируют, что все предшествующие операции записи внутри текущего потока завершатся перед выполнением барьера. Барьер для записи обеспечивает видимость всех изменений переменных после барьера для последующих операций записи.
по сути, барьер памяти - что то вроде фиктивной операции с (memory_order_acquire/memory_order_release) которая позволит создать глобальную точку синхронизации, после которой все предыдущие операции, включая релаксированные, должны быть видны другим потокам, или данный поток подтянет изменения от других потоков.

Используя атомарные переменные, можно реализовать различные асинхронные механизмы, такие как спин-локи. В данном примере создаются два метода:
1. **Lock (Блокировка):** Этот метод проверяет булеву атомарную переменную (атомарный флаг). Если флаг указывает на то, что ресурс разблокирован, метод устанавливает флаг в состояние блокировки и релизит данное изменение (с использованием `memory_order_acq_rel` для обеспечения видимости изменений между потоками). В противном случае метод отказывает в блокировке.
2. **Unlock (Разблокировка):** Этот метод устанавливает флаг в состояние разблокировано и релизит это изменение.
Если требуется ожидание блокировки, проверка на блокировку выполняется в цикле, предоставляя возможность сна потоку при отказе в блокировке.
Таким образом, применение атомарных переменных позволяет эффективно реализовывать синхронизацию между асинхронными сущностями, такими как спин-локи.