- "Неблокирующая" структура данных может включать в себя использование спинлоков для обеспечения безопасности доступа. Это означает, что при необходимости потоки могут использовать спинлоки для обеспечения согласованности доступа к данным, что не исключает возможность параллельного выполнения операций.
- Структура, полностью свободная от блокировок, не может использовать спинлоки. Вместо этого она может оперировать атомарными операциями обмена, возможно, включая цикл, который выполняет подготовительные шаги и начинается заново в случае изменений в критической части структуры данных другими потоками. Этот подход позволяет избежать блокировок, но требует аккуратного управления состоянием структуры.
Если структура открыта для одновременного доступа сразу из нескольких потоков и использует спинлоки, это может свидетельствовать о наличии блокировок, что противоречит концепции полной свободы от блокировок. В таких случаях структура должна быть спроектирована так, чтобы обеспечивать безопасность доступа, не прибегая к использованию спинлоков, и поддерживать возможность одновременного доступа.
- "Свободная от ожидания" структура выполняет свою работу в ограниченное количество шагов, независимо от действий других потоков. Это означает, что она обеспечивает предсказуемость выполнения операций и не зависит от долгих ожиданий, что может улучшить ее производительность в многозадачных сценариях.

"Livelock" (живая блокировка) - это ситуация в параллельном программировании, при которой несколько потоков активны и взаимодействуют друг с другом, но оказываются зацикленными в бесконечном процессе принятия решений, не приводящем к реальному продвижению. Это похоже на блокировку (deadlock), но потоки не простаивают, а пытаются разрешить конфликт, который ведет к зацикливанию.

при создании lock-free структуры мы:
- определяем требования к структуре которые та должна выполнять
- выбераем структуру данных которая сможет поддерживать многопоточность и при этом быть мелкогранулярной (список предпочтительней вектора итд)
- определяем интерфейс структуры так чтоб она не могла нарушить инвариант на уровне интерфейса.
- определение критических частей. Операции которые должны быть атомарны. (пример: установка указателя на новый узел в конец списка)
- обратить внимание на такие ситуации
	- операции состоящие из двух частей потребуют спинлока (тогда мы станем не lock-free)? (так как мне нужно сделать две операции за один шаг, а мы можем сделать только одну)
	пример: установка узла в двусвязный список (переподброска указателя на next и prev)
	- операция копирования все так же недоступна (определена пользователем, может кидать исключение, преведет к патерии данныъх), shared_ptr решает эту проблему
	- следи за указателями, может быть разименоавние удаленных данных, чтоб избежать используй hazard pointer
	- рассмотри возможности гонок в каждом варианте
	- рассмотри случаи работы без элементов, или с переполнением элементами
	- при разработке начинай работу с memory_order_seq_cst в конце оптимизируй смотря по связям между отдельными методами
	- помни про ABA (операция выполняется над одним обектом но под видом двух разных), если переиспользовать одну ноду после удаления например (счетчик ссылок спосет)
	- при активном ожидании мы уже не lock-free но в это время можно попробывать помоч сделать операцию которую мы ждем
	
hazard pointer
- есть три основных варианта, создаем список элементов на удаление и наполняем его, когда эти все элементы гарантированно не кому не нужны удаляем все (заменой старого новым пустым)
- выявляем все потоки обращающиеся к конкретному элементу, когда таких потоков только один текущий, удаляем данный элементами (схема потентована)
- счетчик ссылок на конкретный элемент. если shared_ptr lock-free то используй его, если нет то это будет сложно, но реализуй его сам

Глава невероятно сложная, нужна большое количество практики.