Гонки данных (data racing) - это вид проблем в многозадачных и параллельных программах, возникающих при одновременном доступе к общим данным несколькими потоками (или процессами) без правильной синхронизации. Гонки данных могут привести к непредсказуемым результатам и некорректному поведению программы. 
инвариант - это условие, которое должно быть верным для разделяемых данных в процессе их параллельного доступа и модификации несколькими потоками. Данные условия должны быть верными всегда, и не должны нарушатся при одновремееном доступе из нескольких потоков.

Для сохранения инварианта могут быть использованы такие инструменты:
* использования механизмов синхронизации
* изменение инвариантов таким образом чтоб нарушение было возможно, так же могут использоватся новые особености памяти (lock free programing)

механизмы синхронизации:
Мьютекс (mutex) — это сокращение от "mutual exclusion" (взаимное исключение). Это механизм синхронизации, используемый в многозадачных и многопоточных программах для предотвращения конфликтов доступа к общим ресурсам. Мьютексы обеспечивают взаимное исключение, что означает, что только один поток может владеть мьютексом в конкретный момент времени.
Основные операции с мьютексами включают:
* Блокировка (Lock)
* Разблокировка (Unlock)

Так как после блокировки необходимо обязательно разблокировать мютекс, с ним необходимо использовать RAII иначе в исключительной ситуации мы получим проблемы
RAII обертки над мютексом:
1. **`std::lock_guard`:**
   - **Описание:** Обеспечивает автоматическую блокировку мьютекса при входе в область видимости и автоматическую разблокировку при выходе.
   - **Пример:**\
   `std::lock_guard<std::mutex> lock(myMutex);`
2. **`std::unique_lock`:**
   - **Описание:** Предоставляет большую гибкость, чем `std::lock_guard`. Может быть разблокирован и повторно заблокирован в разных местах кода.
   - **Пример:**\
   `std::unique_lock<std::mutex> lock(myMutex);`
3. **`std::scoped_lock`:**
   - **Описание:** Похож на `std::lock_guard`, но может блокировать сразу несколько мьютексов. Это предотвращает возможность взаимной блокировки при блокировке нескольких мьютексов.
   - **Пример:**\
   `std::scoped_lock lock(myMutex1, myMutex2);`
4. **`std::shared_lock`:**
   - **Описание:** Предоставляет возможность разделяемого доступа к данным, когда блокировка необходима только для чтения. Позволяет множеству потоков одновременно захватывать мьютекс для чтения.
   - **Пример:**\
   `std::shared_lock<std::shared_mutex> lock(mySharedMutex);`

### Для сохранения инвариант
* некогда НЕЛЬЗЯ предоставлять ссылку на защищяемый обект - он может быть по ней изменен, без использования средств синхронизации что нарушит инвариант.
	* защещенные данные некогда не возвращяются ссылкой/указателем вызывающему коду
	* защищенные данные некогда не передаются порметром по ссылке/указателю
	* защищенные данные некогда не сохраняются в видемой извне памяти
* учитывать то что пользовальский тип данных в любой перегрузке оператора или реализации метода может кинуть эксепшен
* не вызывать пользовательский код
* должна быть обеспечена exclusion safty

Не каждый интерфейс способен обеспечить возможность сохранения инварианта в многопоточном режиме, по тому многопоточность необходимо учитывать на этапе проэктировния интерфейса, простой пример Pop и Top в stack две эти операции необходимо обеденить в одну.  

### Гранулярность
Гранулярность блокировок в контексте многозадачных или многопоточных систем относится к тому, насколько крупными или мелкими являются блокировки, которые применяются для защиты общих данных. Определение правильной гранулярности блокировок является важным аспектом оптимизации производительности и предотвращения проблем, таких как взаимная блокировка (deadlock).
Виды гранулярности блокировок:
1. **Грубая (Coarse) Гранулярность:**
   - **Описание:** Одна блокировка для большого объема данных или ресурсов.
   - **Преимущества:** Простота реализации, уменьшение накладных расходов на управление блокировками.
   - **Недостатки:** Возможно больше конфликтов при доступе к различным частям данных, что может снижать параллелизм.
2. **Тонкая (Fine) Гранулярность:**
   - **Описание:** Множество мелких блокировок для различных частей данных или ресурсов.
   - **Преимущества:** Больший параллелизм, минимизация конфликтов при доступе.
   - **Недостатки:** Увеличение накладных расходов на управление блокировками, повышенный риск взаимной блокировки.
Выбор гранулярности блокировок зависит от конкретной ситуации и требований приложения. Некоторые рекомендации по выбору гранулярности:

### Взаимные блокировки:
"Deadlock" (взаимная блокировка) — это ситуация в многозадачной среде, при которой два или более потока (или процесса) находятся в состоянии ожидания друг друга, чтобы освободить ресурсы, необходимые для продолжения выполнения. В результате ни один из этих потоков не может завершить свою работу, и программа оказывается заблокированной.
Для избегания данной проблемы используются такие средства:
Для предотвращения взаимной блокировки (deadlock) в параллельных и распределенных системах применяются различные стратегии и механизмы. Ниже перечислены некоторые из них:

0. избегаются любые иерархические блокировки!
1. Упорядочивание Захвата Ресурсов (Resource Ordering):
	* Установление строгого порядка захвата ресурсов для всех потоков или процессов. Например, требование захвата ресурсов в порядке возрастания их идентификаторов может предотвратить циклическую зависимость захвата ресурсов.
2. Иерархия Блокировок (Lock Hierarchy):
   * Определение иерархии блокировок для ресурсов и требование захвата ресурсов в порядке этой иерархии. Это предотвращает ситуации, когда поток A ожидает ресурс, захваченный потоком B, а поток B ожидает ресурс, захваченный потоком A.
3. Таймауты (Timeouts):
   * Установление временных ограничений на ожидание освобождения ресурсов. Если поток не может захватить ресурс в течение определенного времени, он может выполнять обработку такой ситуации и избегать взаимной блокировки.
4. Предоставление Доступа к Ресурсам в Непоследовательном Порядке: (scoped_lock)
   * Избегание жесткого порядка доступа к ресурсам. Вместо того чтобы требовать последовательного доступа к ресурсам, можно допускать различные порядки доступа, что может снизить вероятность циклической зависимости.

Установка взаимоблакировки может быть так же на этапе интерфейса (двусвязный список, два итератора двигаются на встречу друг другу)
Опасно вызывать пользовательский код удерживая мютекс.

### Полезные средства синхронизации:
std::call_once + sta::once_flag - позволяет вызвать функцию только один раз, очень полезно для ленивой инициализации
boost::shared_mutex - (reder-writer mutex) - обеспечивает монопольный доступ для писателя, и паралельный доступ для любого количества читателей
std::recursive_mutex - мютекс костыль (его применение значит что пора рефакторить), позволяет из одного потока заблокировать его много раз, для разблоки необходимо разблокировать столько же раз сколько было блокировок.
